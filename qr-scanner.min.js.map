{"version":3,"file":"qr-scanner.min.js","sources":["src/qr-scanner.js"],"sourcesContent":["export default class QrScanner {\n    /* async */\n    static hasCamera() {\n        if (!navigator.mediaDevices) return Promise.resolve(false);\n        // note that enumerateDevices can always be called and does not prompt the user for permission. However, device\n        // labels are only readable if served via https and an active media stream exists or permanent permission is\n        // given. That doesn't matter for us though as we don't require labels.\n        return navigator.mediaDevices.enumerateDevices()\n            .then(devices => devices.some(device => device.kind === 'videoinput'))\n            .catch(() => false);\n    }\n\n    constructor(\n        video,\n        onDecode,\n        canvasSizeOrOnDecodeError = this._onDecodeError.bind(this),\n        canvasSize = QrScanner.DEFAULT_CANVAS_SIZE,\n        preferredFacingMode = 'environment'\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._preferredFacingMode = preferredFacingMode;\n        this._active = false;\n        this._paused = false;\n        this._flashOn = false;\n\n        if (typeof canvasSizeOrOnDecodeError === 'number') {\n            // legacy function signature where canvas size is the third argument\n            canvasSize = canvasSizeOrOnDecodeError;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._onDecodeError = canvasSizeOrOnDecodeError;\n        }\n\n        this.$canvas.width = canvasSize;\n        this.$canvas.height = canvasSize;\n        this._sourceRect = {\n            x: 0,\n            y: 0,\n            width: canvasSize,\n            height: canvasSize\n        };\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        this.$video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        this.$video.muted = true;\n        this.$video.disablePictureInPicture = true;\n        this.$video.addEventListener('play', this._onPlay);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n\n        this._qrWorker = new Worker(QrScanner.WORKER_PATH);\n    }\n\n    /* async */\n    hasFlash() {\n        if (!('ImageCapture' in window)) {\n            return Promise.resolve(false);\n        }\n\n        const track = this.$video.srcObject ? this.$video.srcObject.getVideoTracks()[0] : null;\n        if (!track) {\n            return Promise.reject('Camera not started or not available');\n        }\n\n        const imageCapture = new ImageCapture(track);\n        return imageCapture.getPhotoCapabilities()\n            .then((result) => {\n                return result.fillLightMode.includes('flash');\n            })\n            .catch((error) => {\n                console.warn(error);\n                return false;\n            });\n    }\n\n    isFlashOn() {\n      return this._flashOn;\n    }\n\n    /* async */\n    toggleFlash() {\n      return this._setFlash(!this._flashOn);\n    }\n\n    /* async */\n    turnFlashOff() {\n      return this._setFlash(false);\n    }\n\n    /* async */\n    turnFlashOn() {\n      return this._setFlash(true);\n    }\n\n    destroy() {\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n\n        this.stop();\n        this._qrWorker.postMessage({\n            type: 'close'\n        });\n    }\n\n    /* async */\n    start() {\n        if (this._active && !this._paused) {\n            return Promise.resolve();\n        }\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n        this._active = true;\n        this._paused = false;\n        if (document.hidden) {\n            // camera will be started as soon as tab is in foreground\n            return Promise.resolve();\n        }\n        clearTimeout(this._offTimeout);\n        this._offTimeout = null;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            this.$video.play();\n            return Promise.resolve();\n        }\n\n        let facingMode = this._preferredFacingMode;\n        return this._getCameraStream(facingMode, true)\n            .catch(() => {\n                // We (probably) don't have a camera of the requested facing mode\n                facingMode = facingMode === 'environment' ? 'user' : 'environment';\n                return this._getCameraStream(); // throws if camera is not accessible (e.g. due to not https)\n            })\n            .then(stream => {\n                // Try to determine the facing mode from the stream, otherwise use our guess. Note that the guess is not\n                // always accurate as Safari returns cameras of different facing mode, even for exact constraints.\n                facingMode = this._getFacingMode(stream) || facingMode;\n                this.$video.srcObject = stream;\n                this.$video.play();\n                this._setVideoMirror(facingMode);\n            })\n            .catch(e => {\n                this._active = false;\n                throw e;\n            });\n    }\n\n    stop() {\n        this.pause();\n        this._active = false;\n    }\n\n    pause() {\n        this._paused = true;\n        if (!this._active) {\n            return;\n        }\n        this.$video.pause();\n        if (this._offTimeout) {\n            return;\n        }\n        this._offTimeout = setTimeout(() => {\n            const tracks = this.$video.srcObject ? this.$video.srcObject.getTracks() : [];\n            for (const track of tracks) {\n                track.stop(); //  note that this will also automatically turn the flashlight off\n            }\n            this.$video.srcObject = null;\n            this._offTimeout = null;\n        }, 300);\n    }\n\n    /* async */\n    static scanImage(imageOrFileOrUrl, sourceRect=null, worker=null, canvas=null, fixedCanvasSize=false,\n                     alsoTryWithoutSourceRect=false) {\n        let createdNewWorker = false;\n        let promise = new Promise((resolve, reject) => {\n            if (!worker) {\n                worker = new Worker(QrScanner.WORKER_PATH);\n                createdNewWorker = true;\n                worker.postMessage({ type: 'inversionMode', data: 'both' }); // scan inverted color qr codes too\n            }\n            let timeout, onMessage, onError;\n            onMessage = event => {\n                if (event.data.type !== 'qrResult') {\n                    return;\n                }\n                worker.removeEventListener('message', onMessage);\n                worker.removeEventListener('error', onError);\n                clearTimeout(timeout);\n                if (event.data.data !== null) {\n                    resolve(event.data.data);\n                } else {\n                    reject(QrScanner.NO_QR_CODE_FOUND);\n                }\n            };\n            onError = (e) => {\n                worker.removeEventListener('message', onMessage);\n                worker.removeEventListener('error', onError);\n                clearTimeout(timeout);\n                const errorMessage = !e ? 'Unknown Error' : (e.message || e);\n                reject('Scanner error: ' + errorMessage);\n            };\n            worker.addEventListener('message', onMessage);\n            worker.addEventListener('error', onError);\n            timeout = setTimeout(() => onError('timeout'), 10000);\n            QrScanner._loadImage(imageOrFileOrUrl).then(image => {\n                const imageData = QrScanner._getImageData(image, sourceRect, canvas, fixedCanvasSize);\n                worker.postMessage({\n                    type: 'decode',\n                    data: imageData\n                }, [imageData.data.buffer]);\n            }).catch(onError);\n        });\n\n        if (sourceRect && alsoTryWithoutSourceRect) {\n            promise = promise.catch(() => QrScanner.scanImage(imageOrFileOrUrl, null, worker, canvas, fixedCanvasSize));\n        }\n\n        promise = promise.finally(() => {\n            if (!createdNewWorker) return;\n            worker.postMessage({\n                type: 'close'\n            });\n        });\n\n        return promise;\n    }\n\n    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n        this._qrWorker.postMessage({\n            type: 'grayscaleWeights',\n            data: { red, green, blue, useIntegerApproximation }\n        });\n    }\n\n    setInversionMode(inversionMode) {\n        this._qrWorker.postMessage({\n            type: 'inversionMode',\n            data: inversionMode\n        });\n    }\n\n    _onPlay() {\n        this._updateSourceRect();\n        this._scanFrame();\n    }\n\n    _onVisibilityChange() {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    _updateSourceRect() {\n        const smallestDimension = Math.min(this.$video.videoWidth, this.$video.videoHeight);\n        const sourceRectSize = Math.round(2 / 3 * smallestDimension);\n        this._sourceRect.width = this._sourceRect.height = sourceRectSize;\n        this._sourceRect.x = (this.$video.videoWidth - sourceRectSize) / 2;\n        this._sourceRect.y = (this.$video.videoHeight - sourceRectSize) / 2;\n    }\n\n    _scanFrame() {\n        if (!this._active || this.$video.paused || this.$video.ended) return false;\n        // using requestAnimationFrame to avoid scanning if tab is in background\n        requestAnimationFrame(() => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n            QrScanner.scanImage(this.$video, this._sourceRect, this._qrWorker, this.$canvas, true)\n                .then(this._onDecode, (error) => {\n                    if (!this._active) return;\n                    this._onDecodeError(error);\n                })\n                .then(() => this._scanFrame());\n        });\n    }\n\n    _onDecodeError(error) {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    _getCameraStream(facingMode, exact = false) {\n        const constraintsToTry = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n\n        if (facingMode) {\n            if (exact) {\n                facingMode = { exact: facingMode };\n            }\n            constraintsToTry.forEach(constraint => constraint.facingMode = facingMode);\n        }\n        return this._getMatchingCameraStream(constraintsToTry);\n    }\n\n    _getMatchingCameraStream(constraintsToTry) {\n        if (!navigator.mediaDevices || constraintsToTry.length === 0) {\n            return Promise.reject('Camera not found.');\n        }\n        return navigator.mediaDevices.getUserMedia({\n            video: constraintsToTry.shift()\n        }).catch(() => this._getMatchingCameraStream(constraintsToTry));\n    }\n\n    /* async */\n    _setFlash(on) {\n        return this.hasFlash().then((hasFlash) => {\n            if (!hasFlash) return Promise.reject('No flash available');\n            // Note that the video track is guaranteed to exist at this point\n            return this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n                advanced: [{ torch: on }],\n            });\n        }).then(() => this._flashOn = on);\n    }\n\n    _setVideoMirror(facingMode) {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode==='user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    _getFacingMode(videoStream) {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    static _getImageData(image, sourceRect=null, canvas=null, fixedCanvasSize=false) {\n        canvas = canvas || document.createElement('canvas');\n        const sourceRectX = sourceRect && sourceRect.x? sourceRect.x : 0;\n        const sourceRectY = sourceRect && sourceRect.y? sourceRect.y : 0;\n        const sourceRectWidth = sourceRect && sourceRect.width? sourceRect.width : image.width || image.videoWidth;\n        const sourceRectHeight = sourceRect && sourceRect.height? sourceRect.height : image.height || image.videoHeight;\n        if (!fixedCanvasSize && (canvas.width !== sourceRectWidth || canvas.height !== sourceRectHeight)) {\n            canvas.width = sourceRectWidth;\n            canvas.height = sourceRectHeight;\n        }\n        const context = canvas.getContext('2d', { alpha: false });\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(image, sourceRectX, sourceRectY, sourceRectWidth, sourceRectHeight, 0, 0, canvas.width, canvas.height);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    /* async */\n    static _loadImage(imageOrFileOrBlobOrUrl) {\n        if (imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement || imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || window.ImageBitmap && imageOrFileOrBlobOrUrl instanceof window.ImageBitmap\n            || window.OffscreenCanvas && imageOrFileOrBlobOrUrl instanceof window.OffscreenCanvas) {\n            return Promise.resolve(imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof Image) {\n            return QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl).then(() => imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof(imageOrFileOrBlobOrUrl)==='string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl;\n            }\n            return QrScanner._awaitImageLoad(image).then(() => {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n                return image;\n            });\n        } else {\n            return Promise.reject('Unsupported image type.');\n        }\n    }\n\n    /* async */\n    static _awaitImageLoad(image) {\n        return new Promise((resolve, reject) => {\n            if (image.complete && image.naturalWidth!==0) {\n                // already loaded\n                resolve();\n            } else {\n                let onLoad, onError;\n                onLoad = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    resolve();\n                };\n                onError = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    reject('Image load error');\n                };\n                image.addEventListener('load', onLoad);\n                image.addEventListener('error', onError);\n            }\n        });\n    }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.NO_QR_CODE_FOUND = 'No QR code found';\nQrScanner.WORKER_PATH = 'qr-scanner-worker.min.js';\n"],"names":["QrScanner","navigator","mediaDevices","enumerateDevices","then","devices","some","device","kind","catch","Promise","resolve","video","onDecode","canvasSizeOrOnDecodeError","_onDecodeError","bind","canvasSize","DEFAULT_CANVAS_SIZE","preferredFacingMode","$video","$canvas","document","createElement","_onDecode","_preferredFacingMode","_flashOn","_paused","_active","console","warn","width","height","_sourceRect","x","y","_onPlay","_onVisibilityChange","playsInline","muted","disablePictureInPicture","addEventListener","_qrWorker","Worker","WORKER_PATH","window","track","getPhotoCapabilities","result","fillLightMode","includes","error","reject","_setFlash","removeEventListener","stop","postMessage","type","location","protocol","hidden","clearTimeout","_offTimeout","srcObject","play","facingMode","_getCameraStream","stream","_getFacingMode","_setVideoMirror","e","pause","setTimeout","imageOrFileOrUrl","sourceRect","worker","canvas","fixedCanvasSize","alsoTryWithoutSourceRect","createdNewWorker","promise","data","timeout","onMessage","onError","event","NO_QR_CODE_FOUND","_loadImage","image","imageData","buffer","scanImage","finally","red","green","blue","useIntegerApproximation","inversionMode","_updateSourceRect","_scanFrame","start","videoHeight","sourceRectSize","videoWidth","paused","ended","requestAnimationFrame","readyState","log","exact","min","constraintsToTry","forEach","constraint","_getMatchingCameraStream","length","getUserMedia","shift","on","hasFlash","getVideoTracks","applyConstraints","advanced","torch","style","transform","videoStream","test","videoTrack","label","sourceRectWidth","sourceRectHeight","alpha","context","imageSmoothingEnabled","drawImage","sourceRectX","sourceRectY","getImageData","imageOrFileOrBlobOrUrl","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","OffscreenCanvas","Image","_awaitImageLoad","File","Blob","URL","src","createObjectURL","revokeObjectURL","complete","naturalWidth","onLoad"],"mappings":"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"}